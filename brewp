#!/usr/bin/env zsh

set -u

usage() {
    cat 1>&2 <<EOF
brewp
A tool to sync Homebrew packages via Zsh.

USAGE:
    brewp <command|package> [OPTIONS]

COMMANDS:
    sync            Install not-installed packages
    clean           Remove files created by brewp

OPTIONS:
    -h, --help      Print help information
    --cask          Mark as cask packages
    --tap           Mark as taps
EOF
}

say() {
    echo "brewp: $*"
}

err() {
    say "$@" >&2
    exit 1
}

has_cmd() {
    command -v "$1" >/dev/null 2>&1
    return $?
}

need_cmd() {
    if ! has_cmd "$1"; then
        err "requires '$1' (command not found)"
    fi
}

parse_args() {
    # No arguments
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    # check if we have to use /dev/tty to prompt the user
    local need_tty=yes
    for arg in "$@"; do
        case "$arg" in
            -h|--help)
                usage
                exit 0
                ;;
            -y)
                # user wants to skip the prompt -- we don't need /dev/tty
                # shellcheck disable=SC2034
                need_tty=no
                ;;
            *)
                ;;
        esac
    done
}

CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/brewp
CONFIG_PATH="$CONFIG_DIR/config.zsh"

CACHE_DIR=${XDG_CACHE_HOME:-$HOME/.cache}/brewp

PLAN_PATH="$CACHE_DIR/plan"
PLAN_TAP_LIST="$PLAN_PATH/taps.txt"
PLAN_PKG_LIST="$PLAN_PATH/pkgs.txt"
PLAN_CASK_LIST="$PLAN_PATH/casks.txt"

INSTALLED_PATH="$CACHE_DIR/installed"
INSTALLED_TAP_LIST="$INSTALLED_PATH/taps.txt"
INSTALLED_PKG_LIST="$INSTALLED_PATH/pkgs.txt"
INSTALLED_CASK_LIST="$INSTALLED_PATH/casks.txt"

clean() {
    rm -rf "$CACHE_DIR"
}

install() {
    local list_path="$1"
    local installed_list_path="$2"
    local list_command="$3"
    local install_command="$4"

    local installed_list
    installed_list="$(eval brew "$list_command")"
    echo "$installed_list" >! "$installed_list_path"

    # Install not-installed packages
    for line in ${(@f)"$(<"$list_path")"}; do
        if [[ ! $installed_list =~ $line ]]; then
            eval "brew $install_command $line"
        fi
    done
}

sync() {
    if [[ -f "$CACHE_DIR/.brewp-lock" ]]; then
        # Sync should be executed by a single thread.
        err "another brewp process is running"
    fi
    mkdir -p "$INSTALLED_PATH"
    touch "$CACHE_DIR/.brewp-lock"
    trap clean 1 2 3 6 EXIT

    if [[ ! -f $CONFIG_PATH ]]; then
        err "config file not found:" "$CONFIG_PATH"
    fi
    zsh "$CONFIG_PATH" # Load config

    if [[ -f "$PLAN_TAP_LIST" ]]; then
        echo "=== Taps ==="
        paste -s -d ',' "$PLAN_TAP_LIST"
        echo

        install "$PLAN_TAP_LIST" "$INSTALLED_TAP_LIST" "tap" "tap"
    fi
    if [[ -f "$PLAN_PKG_LIST" ]]; then
        echo "=== Packages ==="
        paste -s -d ',' "$PLAN_PKG_LIST"
        echo

        install "$PLAN_PKG_LIST" "$INSTALLED_PKG_LIST" "list --formula -1" "install"
    fi
    # Cask is only for macOS
    if [[ "$OSTYPE" == darwin* ]] && [[ -f "$PLAN_CASK_LIST" ]]; then
        echo "=== Casks ==="
        paste -s -d ',' "$PLAN_CASK_LIST"
        echo

        install "$PLAN_CASK_LIST" "$INSTALLED_CASK_LIST" "list --cask -1" "install --cask"
    fi
}

push() {
    local pkg_name="$1"
    local pkg_list="$PLAN_PKG_LIST"

    if [[ ! -d $PLAN_PATH ]]; then
        mkdir -p "$PLAN_PATH"
    fi

    if [[ $# -eq 2 ]]; then
        if [[ "$2" = '--cask' ]]; then
            # Cask is only for macOS
            if [[ "$OSTYPE" != darwin* ]]; then
                return
            fi
            pkg_list="$PLAN_CASK_LIST"
        elif [[ "$2" = '--tap' ]]; then
            pkg_list="$PLAN_TAP_LIST"
        fi
    fi

    # Push package name back to the package list
    echo "$pkg_name" >>! "$pkg_list"
}

main() {
    need_cmd brew
    need_cmd echo
    need_cmd mkdir
    need_cmd rm
    need_cmd cat
    need_cmd touch
    need_cmd paste
    need_cmd trap

    parse_args "$@"

    case "${@[1]}" in
        sync)
            sync
            ;;
        clean)
            clean
            ;;
        *)
            push "$@"
            ;;
    esac
}

main "$@" || exit 1
