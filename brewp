#!/usr/bin/env zsh

set -u

usage() {
    cat 1>&2 <<EOF
brewp
Sync your Homebrew packages across your devices.

USAGE:
    brewp <command|package> [OPTIONS]

COMMANDS:
    sync            Install not-installed packages
    clean           Remove files created by brewp

OPTIONS:
    -h, --help      Print help information
    --cask          Mark as cask packages
    --tap           Mark as taps
EOF
}

say() {
    echo "brewp: $*"
}

err() {
    say "$@" >&2
    exit 1
}

has_cmd() {
    command -v "$1" >/dev/null 2>&1
    return $?
}

need_cmd() {
    if ! has_cmd "$1"; then
        err "brewp requires '$1' (command not found)"
    fi
}

parse_args() {
    # No arguments
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    # check if we have to use /dev/tty to prompt the user
    local need_tty=yes
    for arg in "$@"; do
        case "$arg" in
            -h|--help)
                usage
                exit 0
                ;;
            -y)
                # user wants to skip the prompt -- we don't need /dev/tty
                # shellcheck disable=SC2034
                need_tty=no
                ;;
            *)
                ;;
        esac
    done
}

CACHE_DIR=${XDG_CACHE_HOME:-$HOME/.cache}/brewp
DATA_DIR=${XDG_DATA_HOME:-$HOME/.local/share}/brewp

TAP_LIST="$DATA_DIR/taps.txt"
PKG_LIST="$DATA_DIR/pkgs.txt"
CASK_LIST="$DATA_DIR/casks.txt"

INSTALLED_TAP_LIST="$CACHE_DIR/taps.txt"
INSTALLED_PKG_LIST="$CACHE_DIR/pkgs.txt"
INSTALLED_CASK_LIST="$CACHE_DIR/casks.txt"

clean() {
    rm -rf "$CACHE_DIR"
    rm -rf "$DATA_DIR"
}

sync_impl() {
    local list_path="$1"
    local installed_list_path="$2"
    local list_command="$3"
    local install_command="$4"

    local installed_list
    if test "$(find "$installed_list_path" -mtime -1 2>/dev/null)"; then
        installed_list="$(cat "$installed_list_path")"
    else
        installed_list="$(eval brew "$list_command")"
        echo "$installed_list" >! "$installed_list_path"
    fi

    local is_anything_installed=false
    for line in ${(@f)"$(<"$list_path")"}
    do
        if [[ ! $installed_list =~ $line ]]; then
            is_anything_installed=true
            eval "brew $install_command $line"
        fi
    done

    # Update the installed list if anything was installed
    if "${is_anything_installed}"; then
        installed_list="$(eval brew "$list_command")"
        echo "$installed_list" >! "$installed_list_path"
    fi
}

sync() {
    if [[ ! -d $CACHE_DIR ]]; then
        # Sync should be executed by a single thread.
        mkdir -p "$CACHE_DIR"
    fi

    if [[ -f "$TAP_LIST" ]]; then
        sync_impl "$TAP_LIST" "$INSTALLED_TAP_LIST" "tap" "tap"
    fi
    if [[ -f "$PKG_LIST" ]]; then
        sync_impl "$PKG_LIST" "$INSTALLED_PKG_LIST" "list --formula -1" "install"
    fi
    # Cask is only for macOS
    if [[ -f "$CASK_LIST" ]] && [[ "$OSTYPE" == darwin* ]]; then
        sync_impl "$CASK_LIST" "$INSTALLED_CASK_LIST" "list --cask -1" "install --cask"
    fi

    rm -rf "$CACHE_DIR"
}

push() {
    local pkg_name="$1"
    local pkg_list="$PKG_LIST"

    if [[ ! -d $DATA_DIR ]]; then
        mkdir -p "$DATA_DIR"
    fi

    if [[ $# -eq 2 ]]; then
        if [[ "$2" = '--cask' ]]; then
            # Cask is only for macOS
            if [[ "$OSTYPE" != darwin* ]]; then
                return
            fi
            pkg_list="$CASK_LIST"
        elif [[ "$2" = '--tap' ]]; then
            pkg_list="$TAP_LIST"
        fi
    fi

    # Create a package list file if not exist
    touch "$pkg_list"
    # Put all unique packages into the package list, with a new package
    echo "$pkg_name" | cat "$pkg_list" - | sort -u -o "$pkg_list"
}

main() {
    need_cmd brew
    need_cmd echo
    need_cmd printf
    need_cmd mkdir
    need_cmd rm
    need_cmd cat
    need_cmd find
    need_cmd sort

    parse_args "$@"

    case "${@[1]}" in
        sync)
            sync
            ;;
        clean)
            clean
            ;;
        *)
            push "$@"
            ;;
    esac
}

main "$@" || exit 1
